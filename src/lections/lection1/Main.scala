package lections

/**
  * Created by GInger on 03.10.16.
  */
object Main extends App {
//                              TODO   Лекция h1 Введение в Scala

    //===========================================================================================
   /*                                 TODO  ВВЕДЕНИЕ
    Scala - компилируемый, (да да, вы узнаете о косяке в коде до момента его запуска)
    обьектно-ориентированный и
    функциональный язык
    со статической типизацией, то есть тип переменной определяется
    в момент ее определения, и если вы как в Perl захотите потом туда положить другой тип, то сорян )
    Десткий сад кончился, это Scala */
    //===========================================================================================

    //===========================================================================================
    /* Любое значение является обьектом, а любая операция вызовом метода
    То есть вполне допустимы такие вещи как */

    "Kinoplan makes me happy".split(" ")
    1.+(10) /* это развернутая запись h1 + 10 */

    /*
    И самое крутое, что больше не нужны точки с запятой, код больше не отвалится из-за того что забыли
        поставить ;
    Исключение - если вам в кайф сделать так, чтобы людям больно было читать ваш код, то можете писать
    все в одну строку,
    и вот тут уже требуется ; между выражениями */

    println("Never press the Enter-button");println("Do you hear me???");println("Never!!!")

    //===========================================================================================
                            /* TODO ОБЬЯВЛЕНИЕ ПЕРЕМЕННЫХ */
       /* В Scala можно выделить три вида обьявления переменной */

    var likePerl = 10

    /* Можно менять, вертеть как душе угодно, главное, чтобы тип не менялся */

    val youShallNotChange = true

    /* Тот же принцип, что и у РПГ - выстрелил, забыл
    Присвоил и забыл)
    Можно сказать что это некий аналог константы, желательно использовать только его,
    избегая как огня var */

    def justAFunction = 1
    /* единственный из трех видов обьявлений, который не требует сразу быть определен,
    о def поговорим чуть позже */
    //============================================================================================
    /*                              TODO ТИПЫ ДАННЫХ                                */
       /* По типам данным тут все немного интереснее, чем в Perl
        У нас есть базовый тип Any, наследник любого типа Scala
        Он в свою очередь делится на AnyVal и AnyRef */
    /*
        AnyRef - Обьекты (String, List, ...)
        AnyVal - Примитивы (Int, Long, Byte, Double, ...)
        Есть тип Unit , который означает ничего , аналог void из C, если вы думаете,
        что ваша функция ничего не возвращает, то увы, она все-таки возвращает Unit
    */

    val tooManyTypes_sadSmile: Int = 10

    /* но тип можно и не указывать )) приятный бонус от Мартина ) он автоматически определится из контекста */
    // TODO Диграмма типов
    /*  http://lmazy.verrech.net/wp-content/uploads/2011/02/scala_type_hierarchy.png */
    //============================================================================================
   /*                               TODO УСЛОВИЯ                                                */
    /*

    На первый взгляд условный оператор if else не отличается от своего Perl или Js собрата
        НО! Это чертвовски ошибочное мнение

    TODO if else в Scala это не оператор, !!!!!!
    а выражение а значит теперь мы можем присвоить его в переменную

    */

    val wow = if (10 == 10 && 5 > 4) 10 else 20

    /*

    Выглядит easy :) Как видите и тип указывать не надо, Scala сама пишет за вас код )
    Но не все так просто )

    */

    val scalaIsBetterProgrammerThenYou = if (true) 20 else "Oops"

    /*

    Согласно табличке с типами Scala приведет результат к ближайщему общему типу - Any
    если не указывать блок else то автоматом туда положится Unit, а дальше по старой схеме, общий тип

    */

    //============================================================================================
   /*                                   TODO ЦИКЛЫ                                              */

   /* В Scala есть несколько способов выполнить однотипные операции */
    /*
    TODO h1)
    TODO По - индусски */

    println(1)
    println(2)
    println(3)
    println(4)

    /*
    TODO 2)
    TODO Циклы */

    for (i <- 1.to(10)) {
        println(i)
    }

    for (i <- 0 until 10 if i % 2 == 0) {
        //можно фильтровать данные сразу внутри цикла
    }

//    Но мы используем конструкцию for для абсолютно других вещей ...

    /*
    TODO 3)
    TODO в функциональном стиле - но об этом в следующий раз */


    //============================================================================================
    /*                                  TODO ФУНКЦИИ                                            */
    /*

    Функции в Scala можно вызывать,
    передавать как параметр в другую функцию,
    возвращать функцию из функции ...
    Как говорится на что у кого фантазии хватит

    */

    /* То есть функции являются полноценными обьектами и имеют свой тип

    h1)Описываются ф-ии с помощью слова def
    2)Далее следует имя
    3)Далее в круглых скобках параметры с указанием типа в форме name:Type,
    однако можно обойтись и без входящих параметров
    4)Далее опционально (для перфекционистов тип возвращаемого значения)
    Если вы пишете рекурсивную функцию, то тип возвращаемого значения обязателен
*/
    /*
        Иногда кажется что где то написана вот такая функция, и она периодически вызывается
    */

    /* TODO Thanks to this function we have a job */
    def shutDownKinoplan(code: Int, message: String): Boolean = {
        //make black magic
        //show message with code
        //Oops
        true
    }

   /*
   и как видите нет слова return, из функции а точнее из блока возвращается всегда последнее значение
        по тому же принципу работает if () {} else {}
   */

    /*
    Если совсем лень передавать параметры то можно обьявить некоторые
    TODO параметры по умолчанию
    */

    def shutDownKinoplanStandartWay(message: String, code:Int = 500) = {
        println(s"We have the error $message with $code")
    }

    shutDownKinoplanStandartWay(" Shit happens :) ")

    /*
    как видно не требуется указывать code если он 500 , прям безысходность какая-то ... :(
    */

    /*
    Но я все же предпочитаю другой способ вызова -
    TODO именованные параметры
     */

    shutDownKinoplanStandartWay(message = " Будешь знать, как в чате жаловаться...) ")
    shutDownKinoplanStandartWay(code = 404, message = " Будешь знать, как в чате жаловаться...) ")

    /*
    так можно инициализировать параметры в любом порядке, хоть по алфавиту, хоть по количеству букв в слове,
    опять же кто на что горазд :)
    */

    /*
    TODO можно передавать переменное число параметров в функцию
     */

    def justForExperiment(params: String*) = {
        for (p <- params) {
            println(p)
        }
    }

    justForExperiment("¯\\_(ツ)_/¯ ", "┌( ಠ‿ಠ)┘ ")
    justForExperiment("Пиши", "пока", "не надоест", "!!!")

    /* TODO Передача функции в функцию */

    /* У нас есть две функции которые выводят информацию в своем стиле */

    def write(data: String) = {
        println(s"WRITE - $data")
    }
    def say(data: String) = {
        println(s"SAY - $data")
    }

    /* и есть универсальная функция, которая принимает data и tool - наша форматированный вывод */

    def motivateMe(data: String, tool: (String) => Unit) = {
        tool(data)
    }

    motivateMe("I will become a Scala hero!!!", write)
    motivateMe("I rewrite kinoplan.ru", say)

    /* TODO но также можно передавать лямбды (анонимные функции) */

    motivateMe("I will do it", text => println(text))

    /* можно заключить тело лямбды в {} */

    motivateMe("Yeah!", text => {
      println(text)
    })

    /* TODO Возвращение функции из функции */

    def buildKinoplan( isPersonLikeScala: Boolean ): ((String, Int) => Int) = {
        if ( isPersonLikeScala ) {
            ( message, code ) => { println(s"I can build it $message"); code }
        } else {
            ( message, _ ) => { println(s"It's your biggest fault....$message"); 500 }
            /*
            Интересная вещь, если мы не используем переменную то можем ее заменить знаком _
            У нас в примере code не используется, и мы можем вместо него поставить _
            также лямбды у которых всего одно выражение в теле, и которые вызывают функции аргумента
            s => s.toLowerCase могут быть заменены на _.toLowerCase
            */
        }
    }

    buildKinoplan(true)("JUST DO IT !!! YES YOU CAN !!!", 200)

    def dontLikeScala = buildKinoplan(false)
    dontLikeScala("Let's deploy it on Friday", 200)

    //============================================================================================

    /*
                                /* TODO -------HOMEWORK-------- */

    TODO Функции обработки
    //Замечание TYPE:params* разворачивается при вызове в Seq[TYPE]
    h1) Написать функцию поиска минимума из списка параметров функции ( params: Seq[Double] )
    2) Написать функцию поиска максимума из списка параметров функции ( params: Seq[Double] )
    3) Написать функцию поиска среднего арифметического из списка параметров функции ( params: Seq[Double] )

    TODO Функция вывода
    4) Написать несколько функций (Double) => Unit которые выводят на экран значение в какой то особой форме (см. пример в лекции )

    5) И теперь реализуем паттерн Стратегия
    Создайте функцию которая принимает функцию обработки, функцию вывода и список параметров и
     выводит на экран с помощью функции вывода результат применения функции обработки к списку параметров
     Предусмотрите значения по умолчанию

    6) Напишите функцию, которая выводит на экран N первых простых чисел
    */
}
